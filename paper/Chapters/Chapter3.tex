\chapter{Energy-aware Gossip}

The objective of gossip protocol is to broadcast messages in an efficient way by mimicing social activities when people spread rumors in office. It works as follows: when a node received a new message, it then will send it to multiple nodes in the network. The number of nodes it contacted is defined as the \emph{fanout} of gossip protocol. It is denoted as $f$. Each time when a node face the decision of sending a new message to another node, the probability of doing so is defined as $p_{gossip}$. In the rest of the thesis, I will refer to it as $p_g$. $p_g$ is between 0 and 1. Once a node received a new message, the number of times it will contact other nodes is defined as \emph{message live time}. It is denoted as $T_l$.


\section{Classcial Gossip}
For classic gossip protocol in wired network sceniro, \emph{probability of gossip} is set to be 1 and \emph{fanout} is usually set to be 1 or 2. \emph{Message live time} could vary depending on the requirement. In a wireless adhoc network sceniro, even though each node has the ability to broadcast locally, it is often not utilized due to pontential broadcast storm problem. Instead \emph{fanout} is set to be 1 or 2 as well. However, it is desirable to set \emph{probability of gossip} to be a number below 1 in order to reduce protocol overhead. Some paper proposed a global $p_g$ based on the connectivity of the network. A typical value is about 0.6. The intuition behind this approach is that from our life experience, a rumor can be successfully spread even whithout everyone's participation. Thus, a \emph{probability of gossip} value set below 1 will still allow new messages to be broadcasted with reasonably high successful rate. However, it is often difficult to gather global information in a wireless adhoc network due to its distributed and dynamic nature. Therefore, even an optimal global $p_g$ could become sub-optimal overtime. 

To address these issues, some paper proposed dynamic global $p_g$ where frequently the protocol will gather network information(such as number of nodes in the network) to adjust $p_g$. This approach does take dynamic network topology into account but gathering global network information remain to be difficult. Meanwhile, some paper proposed dynamic $p_g$ for each individual node. The \emph{probability of gossip} can be adjusted based on its node's degree (define as the number of neighbors, denoted as $d$) or based on how many times a node overheard the same message. Here a node's degree is be used as a density metrics. Idealy in order to reduce overhead, we want $p_g$ to be inversely correlated with node's degree. The equation is shown as:

\[ p_g = \frac{1}{d}\]

The basic idea behind this approach is that for a node with higher node's degree (meaning it has more neighbors, thus this area is more dense), a lower \emph{probability of gossip} will be sufficient to spread out the new message.

For the aprroach that focus on how many times a node overheard the same message, during a small time frame $\tau$ (e.g. 5s), a node will listen messages that are being sent to other nodes. If the times this node overhear the same message exccees its threshold, it will not send its latest message to one or several randomly selected neighbors. 

\subsection{How it works}

\subsection{Mathmatical model of gossip protocol}

\subsection{All Parameters}
Four key parameters that define the behavior of gossip protocol in a wireless adhoc network are: 

\begin{itemize}
	\item \emph{probability of gossip}(denoted as $p_g$)
	\item \emph{fanout} (denoted as $f$)
	\item \emph{message live time} (denoted as $T_l$)
	\item \emph{gossip interval} (when $T_l > 1$)
\end{itemize}

When $p_g = 1$ and $f = node's degree$, this protocol is closely resemble to flooding broadcasting scheme which is not suitable for wireless adhoc network. When $p_g = 1$ and $f = 1, 2$, it is set to be classic gossip broadcast protocol. $T_l$ is a parameter that is closely related to a node's memory constrain. A large $T_l$ setting will is will increase the message broadcasting successful rate at the expnse of higher memory requirement and higher protocol overhead. 

\subsection{Different Approach}

\section{Proposed Energy-aware Adaptive Gossip}
As we stated previsouly in the thesis, the current state of research on gossip techniques for wireless broadcassting focused very little on energy efficiency and network lifetime. Far too many researches focused on dynamically adjust $p_g$ based on global or local network infromation (global: number of nodes, local: node's degree, overhearring). Our objective here is to develop a new energy-aware gossip protocol that could extend network lifetime while still remain to have a fast and reliable broadcasting performance. The parameter that we focused on shifted from \emph{probability of gossip} to \emph{fanout} as well. 

Our observation tells us that a higher \emph{fanout} setting will result in a shorter broadcasting time for a new message at the expense of higher energy consumption. While a lower \emph{fanout} setting will conserve energy but result in a longer broadcasting time. First of all, we argue that each node's battery life should be maximized in order to extend network lifetime. Since for a broadcasting protocol, any node that disconnected to the network due to energy depletion renders a situation that broadcasting can no longer work. In order to maximize each node's battery life, a constant high \emph{fanout} setting is undesirable when battery is very low. Similarly when battery is very high, a constatnt low \emph{fanout} setting can hinder the message broadcasting time. Therefore, we proposed that \emph{fantou} should be dynamically adjusted based on each node's remaining energy fraction. 

Let's denoted the \emph{remaining energy fraction} as $r$. The fanout fucnntion is as follow:

\[ f(r) = 5 when 0.8 \leq r \leq 1\]

The fanout function is plotted as follow:


The basic idea of our fanout function is that if a node has high remaining energy, the \emph{fanout} of that node will be higher and vice versa. 


\section{Basic Gossip Protocol Details}
The actual protocol utilizes three packet types to perform. They are:
\begin{itemize}
	\item Data packet
	\item Ack packet  (Acknowledgment)
	\item Request packet
\end{itemize}

The Data packet contains the message that is expected to be disseminated to the whole network from a certain source node. The Ack packet is used to acknowledge to the sender that receiver node already received that message before. The Request packet is used for a node to ask for the latest message from destination node. There are two states for each node, gossipping or sleep.


(from 563 paper).

\begin{figure}
	\centering
	\begin{verbatim}[fontsize=\small]
	switch(state):
	case running:
		if message is not null:
			every 5 milliseconds:
				find a random neighbor R
				send data packet to R
		if receive a packet:
			if packet is ACK:
				state <- stop
			if packet is data:
				send ACK to packet source
		else:
			if receive a packet:
	if packet is a data packet:
	update the message
	every 5 seconds:
	find a random neighbor R
	send a request packet to R
	if receive a packet:
	if packet is a data packet:
	update the message to data
	
	case stop:
	if receive a packet:
	if packet is request:
	send data to the source node
	if packet is data:
	send ACK to the source node
	\end{verbatim}
	\caption{The pseudo code of the gossip algorithm.}
	\label{fig:pseudo}
\end{figure}

The pseudo code of gossip algorithm is given in figure~\ref{fig:pseudo}. All nodes in the network have same behavior and they are independent to each other. When user would like to spread a message x to the whole network, the protocol randomly assign the message x to a node and run this algorithm. For the discussion, let's assume node 1 got the initial message x. Node 1 start with running state, and node 1 has a message x, so it will find a random neighbor every 0.005s and send a data packet which contain message x to its random neighbor. If node 1 receive a ACK packet it will go to stop state, otherwise it will keep doing above steps. Other nodes which do not have the message x will wait for packet, if a node 1 send a data packet to the node 2 which do not have message x, node 2 will update the message x in node 2 and not return anything to node 1. If node 2 do not have message 2, it will send a request packet to a random neighbor every 5 second. If node 2 receives a data packet after sending the request packet, it will update its message to x. The nodes in stop state would always waiting for other node send control messages to it and it will send data packet or ACK packet back depends on what kind of packets it receives.
